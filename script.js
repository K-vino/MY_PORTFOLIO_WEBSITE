// script.js
// Author: Vino K. (Generated by Gemini)
// Description: Main JavaScript file for Vino K's personal portfolio website.
// Handles dynamic functionalities, advanced animations, UI interactions,
// form submissions via Formspree, and various UI/UX enhancements.
// Version: 3.0.0
// Last Updated: June 21, 2025

/* ======================================================= */
/* GLOBAL VARIABLES & IMPORTS              */
/* ======================================================= */

// No Firebase imports or configuration here, as per requirements.

// Third-party libraries (assumed to be loaded via CDN in HTML)
// - Typed.js
// - AOS (Animate On Scroll)
// - Chart.js
// - GSAP (GreenSock Animation Platform) - including ScrollTrigger plugin
// - particles.js

// DOM Elements Cache - Centralized for easy access and performance
const DOMElements = {
    // === Page Structure ===
    header: null,
    navbar: null,
    navList: null,
    navLinks: null,
    menuIcon: null,
    mainContent: null,
    footer: null,
    liveTimeSpan: null,

    // === UI Controls ===
    darkModeToggle: null,
    themeCustomizerToggle: null,
    themeCustomizer: null,
    customizerCloseBtn: null,
    colorOptions: null,
    fontSizeOptions: null,
    resetThemeBtn: null,
    skipLink: null,
    backToTopBtn: null,
    scrollProgressBar: null,
    messageBox: null,
    messageBoxText: null,
    messageBoxCloseBtn: null,

    // === Home Section ===
    homeSection: null,
    typedSubtitle: null,
    homeButtons: null,
    homeProfileImg: null,
    homeImageBlob: null,
    particlesJsDiv: null, // New: for particles.js container

    // === Skills Section ===
    skillsChartCanvas: null,
    skillItems: null,

    // === Projects Section ===
    projectCards: null,
    projectModal: null,
    projectModalTitle: null,
    projectModalImage: null,
    projectModalDescription: null,
    projectModalTechStack: null,
    projectModalCodeLink: null,
    projectModalDemoLink: null,
    projectModalCloseBtn: null,

    // === Certifications Section ===
    certificationCards: null,
    certificationModal: null,
    certificationModalTitle: null,
    certificationModalProvider: null,
    certificationModalDate: null,
    certificationModalCredentialLink: null,
    certificationModalCloseBtn: null,

    // === Resume Section ===
    resumeDownloadBtn: null,
    resumeViewTabBtn: null,

    // === Contact Form ===
    contactForm: null,
    contactName: null,
    contactEmail: null,
    contactSubject: null,
    contactMessage: null,
    contactSubmitBtn: null,
    copyEmailBtn: null,
    copyPhoneBtn: null,

    // === Custom Cursor ===
    cursorDot: null,
    cursorOutline: null,
};

// Application State Management
const appState = {
    isPreloaderHidden: false, // Tracks if preloader has been hidden
    activeSection: 'home', // Current active section for nav highlighting
    theme: {
        primaryColor: '#754ef9', // Default primary color
        isLightMode: false,      // Default to dark mode
        fontSize: 'base',        // Default font size
    },
    timers: {
        debounce: null,
        throttle: null,
        messageBox: null,
    },
    // Keep track of dynamically loaded module states if needed for larger apps
    modulesLoaded: {
        gsapScrollTrigger: false,
        particlesJs: false,
    },
    modalOpen: false, // Tracks if any modal is currently open
};

// Constants for configuration
const APP_CONSTANTS = {
    DEBOUNCE_DELAY: 150, // Milliseconds for debouncing scroll, resize
    THROTTLE_DELAY: 16,  // Milliseconds for throttling mousemove (approx. 60 FPS)
    SCROLL_OFFSET: 80,   // Pixels offset for active nav link calculation
    PRELOADER_MIN_DISPLAY_TIME: 1000, // Minimum time preloader is shown (ms)
    MESSAGE_BOX_DISPLAY_TIME: 7000, // Message box display duration (ms)
    FORM_SUCCESS_MESSAGE: "Thank you for your message! I will get back to you soon.",
    FORM_ERROR_MESSAGE: "Oops! There was an error sending your message. Please try again later.",
    FORM_LOADING_TEXT: "Sending...",
    FORM_DEFAULT_TEXT: "Send Message",
    GSAP_EASE_OUT: "power2.out",
    GSAP_BACK_OUT: "back.out(1.7)",
    GSAP_STAGGER_DELAY: 0.15,
    // Add more constants as needed
};

// Colors for dynamic CSS variable updates (RGB format for rgba usage in CSS)
const COLOR_PALETTES_RGB = {
    '#754ef9': '117, 78, 249', // Primary Purple
    '#00aaff': '0, 170, 255',  // Blue
    '#ff4d4d': '255, 77, 77',  // Red
    '#50e3c2': '80, 227, 194', // Teal
    '#ffc107': '255, 193, 7',  // Amber
};

/* ======================================================= */
/* HELPER FUNCTIONS - Utility and DOM Manipulation         */
/* ======================================================= */

/**
 * Safely retrieves a single DOM element.
 * Logs a warning if the element is not found, aiding debugging.
 * @param {string} selector - The CSS selector string.
 * @returns {HTMLElement | null} The found element or null.
 */
function getElement(selector) {
    const element = document.querySelector(selector);
    if (!element) {
        console.warn(`[DOM Helper] Element with selector "${selector}" not found.`);
    }
    return element;
}

/**
 * Safely retrieves a NodeList of DOM elements.
 * @param {string} selector - The CSS selector string.
 * @returns {NodeListOf<HTMLElement>} A NodeList (can be empty if no elements found).
 */
function getAllElements(selector) {
    const elements = document.querySelectorAll(selector);
    // console.log(`[DOM Helper] Found ${elements.length} elements for "${selector}".`); // Uncomment for verbose logging
    return elements;
}

/**
 * Applies a CSS class to an element if it exists.
 * @param {HTMLElement | null} element - The DOM element.
 * @param {string} className - The class name to add.
 */
function addClass(element, className) {
    if (element) {
        element.classList.add(className);
    }
}

/**
 * Removes a CSS class from an element if it exists.
 * @param {HTMLElement | null} element - The DOM element.
 * @param {string} className - The class name to remove.
 */
function removeClass(element, className) {
    if (element) {
        element.classList.remove(className);
    }
}

/**
 * Toggles a CSS class on an element if it exists.
 * @param {HTMLElement | null} element - The DOM element.
 * @param {string} className - The class name to toggle.
 * @param {boolean} [force] - If true, adds the class; if false, removes it.
 */
function toggleClass(element, className, force) {
    if (element) {
        element.classList.toggle(className, force);
    }
}

/**
 * Sets a CSS variable on the document root.
 * @param {string} varName - The name of the CSS variable (e.g., '--primary-color').
 * @param {string} value - The value to set.
 */
function setCSSVar(varName, value) {
    document.documentElement.style.setProperty(varName, value);
}

/**
 * Gets the computed value of a CSS variable from the document root.
 * @param {string} varName - The name of the CSS variable.
 * @returns {string} The computed value.
 */
function getCSSVar(varName) {
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}

/**
 * Debounce function to limit how often a function can run.
 * Useful for event listeners that fire rapidly (e.g., scroll, resize).
 * @param {Function} func - The function to debounce.
 * @param {number} delay - The debounce delay in milliseconds.
 * @returns {Function} The debounced function.
 */
function debounce(func, delay) {
    return function (...args) {
        clearTimeout(appState.timers.debounce);
        appState.timers.debounce = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Throttle function to limit how often a function can run per unit of time.
 * Useful for high-frequency events like mousemove.
 * @param {Function} func - The function to throttle.
 * @param {number} delay - The throttle delay in milliseconds.
 * @returns {Function} The throttled function.
 */
function throttle(func, delay) {
    let lastExec = 0;
    return function (...args) {
        const now = Date.now();
        if (now - lastExec >= delay) {
            lastExec = now;
            func.apply(this, args);
        }
    };
}

/**
 * Saves a preference to localStorage.
 * @param {string} key - The key for the preference.
 * @param {any} value - The value to store.
 */
function savePreference(key, value) {
    try {
        localStorage.setItem(key, JSON.stringify(value));
        // console.log(`[Preference] Saved: ${key} = ${JSON.stringify(value)}`);
    } catch (e) {
        console.error(`[Preference] Error saving "${key}" to localStorage:`, e);
    }
}

/**
 * Loads a preference from localStorage.
 * @param {string} key - The key for the preference.
 * @param {any} defaultValue - The default value if the key is not found or parsing fails.
 * @returns {any} The loaded value or the default value.
 */
function loadPreference(key, defaultValue) {
    try {
        const value = localStorage.getItem(key);
        const parsedValue = value ? JSON.parse(value) : defaultValue;
        // console.log(`[Preference] Loaded: ${key} = ${JSON.stringify(parsedValue)}`);
        return parsedValue;
    } catch (e) {
        console.error(`[Preference] Error loading "${key}" from localStorage:`, e);
        return defaultValue;
    }
}

/**
 * Displays a custom message box instead of native alert/confirm.
 * @param {string} message - The message text to display.
 * @param {'info' | 'success' | 'error'} type - The type of message for styling.
 */
function showMessageBox(message, type = 'info') {
    const msgBox = DOMElements.messageBox;
    const msgText = DOMElements.messageBoxText;

    if (!msgBox || !msgText) {
        console.warn('[MessageBox] Message box elements not found. Logging to console instead:', message, `Type: ${type}`);
        return;
    }

    // Clear any existing timeout to allow a new message to display fully
    clearTimeout(appState.timers.messageBox);

    // Reset classes and apply new type
    msgBox.className = `message-box ${type}`;
    msgText.textContent = message;
    msgBox.style.display = 'flex'; // Make visible

    // Set timeout to hide the message box
    appState.timers.messageBox = setTimeout(() => {
        msgBox.style.display = 'none';
        msgBox.classList.remove(type); // Clean up class
    }, APP_CONSTANTS.MESSAGE_BOX_DISPLAY_TIME);
}

/**
 * Manually closes the custom message box.
 */
function closeMessageBox() {
    if (DOMElements.messageBox) {
        clearTimeout(appState.timers.messageBox); // Clear auto-hide timer
        DOMElements.messageBox.style.display = 'none';
        // Remove type classes to ensure clean state for next message
        DOMElements.messageBox.classList.remove('info', 'success', 'error');
    }
}

/**
 * Copies text to the clipboard. Uses document.execCommand('copy') for better iframe compatibility.
 * @param {string} text - The text to copy.
 * @returns {boolean} True if successful, false otherwise.
 */
function copyTextToClipboard(text) {
    let textArea;
    try {
        textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";  // Ensure it's off-screen
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.width = "1px";
        textArea.style.height = "1px";
        textArea.style.padding = "0";
        textArea.style.border = "none";
        textArea.style.outline = "none";
        textArea.style.boxShadow = "none";
        textArea.style.background = "transparent";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        const success = document.execCommand('copy');
        if (success) {
            showMessageBox('Copied to clipboard!', 'success');
        } else {
            showMessageBox('Failed to copy to clipboard.', 'error');
        }
        return success;
    } catch (err) {
        console.error('Copy to clipboard failed:', err);
        showMessageBox('Failed to copy to clipboard.', 'error');
        return false;
    } finally {
        if (textArea && textArea.parentNode) {
            textArea.parentNode.removeChild(textArea);
        }
    }
}


/* ======================================================= */
/* 2. PRELOADER LOGIC                                      */
/* ======================================================= */

/**
 * Initializes the preloader, showing it and then fading it out
 * when the page is fully loaded, after a minimum display time.
 */
function initPreloader() {
    if (!DOMElements.preloader) return;

    // Initially hide body overflow to prevent scrolling during preloader display
    document.body.style.overflow = 'hidden';

    let loadStartTime = Date.now(); // Record when initPreloader starts

    window.addEventListener('load', () => {
        let loadEndTime = Date.now();
        let displayDuration = loadEndTime - loadStartTime;
        let delay = 0;

        // Ensure preloader is shown for at least PRELOADER_MIN_DISPLAY_TIME
        if (displayDuration < APP_CONSTANTS.PRELOADER_MIN_DISPLAY_TIME) {
            delay = APP_CONSTANTS.PRELOADER_MIN_DISPLAY_TIME - displayDuration;
        }

        setTimeout(() => {
            addClass(DOMElements.preloader, 'hidden');
            // Allow scroll back after preloader is fully hidden
            DOMElements.preloader.addEventListener('transitionend', () => {
                document.body.style.overflow = '';
                appState.isPreloaderHidden = true; // Update state
            }, { once: true });
        }, delay);
    });
}

/* ======================================================= */
/* 3. CUSTOM CURSOR LOGIC                                  */
/* ======================================================= */

/**
 * Initializes the custom cursor to follow the mouse and react to interactive elements.
 * Requires GSAP.
 */
function initCustomCursor() {
    if (typeof gsap === 'undefined' || !DOMElements.cursorDot || !DOMElements.cursorOutline) {
        console.warn('[Custom Cursor] GSAP or cursor elements not found. Skipping custom cursor.');
        return;
    }

    gsap.set(DOMElements.cursorDot, { xPercent: -50, yPercent: -50 });
    gsap.set(DOMElements.cursorOutline, { xPercent: -50, yPercent: -50 });

    const cursorX = { value: 0 };
    const cursorY = { value: 0 };

    window.addEventListener('mousemove', (e) => {
        gsap.to(cursorX, { value: e.clientX, duration: 0.1 });
        gsap.to(cursorY, { value: e.clientY, duration: 0.1 });
    });

    // Update cursor position on every GSAP tick for smooth animation
    gsap.ticker.add(() => {
        gsap.set(DOMElements.cursorDot, { x: cursorX.value, y: cursorY.value });
        gsap.to(DOMElements.cursorOutline, {
            x: cursorX.value,
            y: cursorY.value,
            duration: 0.2, // Slightly slower than dot for trail effect
            ease: APP_CONSTANTS.GSAP_EASE_OUT
        });
    });

    // Handle cursor hover states for interactive elements
    const interactiveElements = getAllElements('a, button, input, textarea, .project-card, .service-card, .skill-item, .certification-card, .control-btn');

    interactiveElements.forEach(el => {
        el.addEventListener('mouseenter', () => {
            addClass(DOMElements.cursorDot, 'hovered');
            addClass(DOMElements.cursorOutline, 'hovered');
        });
        el.addEventListener('mouseleave', () => {
            removeClass(DOMElements.cursorDot, 'hovered');
            removeClass(DOMElements.cursorOutline, 'hovered');
        });
    });

    // Initial opacity for the cursor (hidden until mouse moves)
    gsap.to([DOMElements.cursorDot, DOMElements.cursorOutline], {
        opacity: 1,
        duration: 0.5,
        delay: 1, // Delay showing until after preloader might be gone
        ease: "power2.out"
    });
}


/* ======================================================= */
/* 4. SCROLL PROGRESS BAR LOGIC                            */
/* ======================================================= */

/**
 * Updates the scroll progress bar based on current scroll position.
 * This function is throttled for performance.
 */
const updateScrollProgressBar = throttle(() => {
    if (!DOMElements.scrollProgressBar) return;
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    // Calculate scroll percentage. Avoid division by zero for very short pages.
    const scrollPercent = (scrollHeight - clientHeight) > 0 ?
                          (scrollTop / (scrollHeight - clientHeight)) * 100 : 0;
    DOMElements.scrollProgressBar.style.width = `${scrollPercent}%`;
}, APP_CONSTANTS.THROTTLE_DELAY);


/* ======================================================= */
/* 5. BACK TO TOP BUTTON LOGIC                             */
/* ======================================================= */

/**
 * Shows or hides the back-to-top button based on scroll position.
 */
const toggleBackToTopButton = debounce(() => {
    if (!DOMElements.backToTopBtn) return;
    if (window.scrollY > 300) {
        addClass(DOMElements.backToTopBtn, 'show');
    } else {
        removeClass(DOMElements.backToTopBtn, 'show');
    }
}, APP_CONSTANTS.DEBOUNCE_DELAY);

/**
 * Scrolls the page to the top smoothly when the button is clicked.
 */
function scrollToTop() {
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
}


/* ======================================================= */
/* 6. HEADER & NAVIGATION LOGIC                            */
/* ======================================================= */

/**
 * Adds or removes the 'scrolled' class to the header for sticky/blur effect.
 */
const handleStickyHeader = debounce(() => {
    if (!DOMElements.header) return;
    toggleClass(DOMElements.header, 'scrolled', window.scrollY > 50);
}, APP_CONSTANTS.DEBOUNCE_DELAY);

/**
 * Highlights the active navigation link based on current scroll position.
 * Uses GSAP ScrollTrigger for more robust section tracking.
 */
function highlightActiveNavLink() {
    if (!DOMElements.navLinks || typeof ScrollTrigger === 'undefined') {
        console.warn('[Nav Highlight] Nav links or ScrollTrigger not found. Skipping active nav highlighting.');
        return;
    }

    // Reset all active classes first
    DOMElements.navLinks.forEach(link => removeClass(link, 'active'));

    // Re-initialize ScrollTriggers if they exist (or set up initially)
    if (!appState.modulesLoaded.gsapScrollTrigger) {
        // Only register ScrollTriggers once
        gsap.utils.toArray('section[id]').forEach(section => {
            ScrollTrigger.create({
                trigger: section,
                start: `top center+=${APP_CONSTANTS.SCROLL_OFFSET}`, // When section top hits middle of viewport + offset
                end: `bottom center+=${APP_CONSTANTS.SCROLL_OFFSET}`,
                onEnter: () => updateNavLink(section.id),
                onEnterBack: () => updateNavLink(section.id),
                // optional: onLeave, onLeaveBack if more complex transitions are needed
            });
        });
        appState.modulesLoaded.gsapScrollTrigger = true;
    }

    // Manual update for the very first load or if ScrollTrigger isn't active yet
    const currentScrollY = window.scrollY;
    let activeSectionId = 'home'; // Default to home

    getAllElements('section[id]').forEach(section => {
        const sectionTop = section.offsetTop - (DOMElements.header ? DOMElements.header.offsetHeight : 0) - APP_CONSTANTS.SCROLL_OFFSET;
        const sectionBottom = sectionTop + section.offsetHeight;

        if (currentScrollY >= sectionTop && currentScrollY < sectionBottom) {
            activeSectionId = section.id;
        }
    });
    updateNavLink(activeSectionId); // Set initial active link
}

/**
 * Helper to update the active class on navigation links.
 * @param {string} sectionId - The ID of the currently active section.
 */
function updateNavLink(sectionId) {
    if (appState.activeSection === sectionId) return; // Prevent unnecessary updates

    appState.activeSection = sectionId;
    DOMElements.navLinks.forEach(link => {
        if (link.getAttribute('href').includes(sectionId)) {
            addClass(link, 'active');
        } else {
            removeClass(link, 'active');
        }
    });
}

/**
 * Toggles the mobile navigation menu's visibility and manages body scroll.
 */
function toggleMobileMenu() {
    if (!DOMElements.navbar || !DOMElements.menuIcon) return;
    const isActive = DOMElements.navbar.classList.contains('active');
    toggleClass(DOMElements.navbar, 'active', !isActive);
    toggleClass(DOMElements.menuIcon, 'active', !isActive);
    toggleClass(document.body, 'no-scroll', !isActive); // Prevent body scroll when menu is open
}

/**
 * Sets up smooth scrolling for all navigation links and other internal anchors.
 */
function setupSmoothScrolling() {
    getAllElements('a[href^="#"]').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);

            if (targetElement) {
                // Close mobile menu if open
                if (DOMElements.navbar && DOMElements.navbar.classList.contains('active')) {
                    toggleMobileMenu();
                }

                // Smooth scroll, accounting for fixed header height
                const offsetTop = targetElement.offsetTop - (DOMElements.header ? DOMElements.header.offsetHeight : 0) - (targetId === 'home' ? 0 : 20); // No offset for home
                window.scrollTo({
                    top: offsetTop,
                    behavior: 'smooth'
                });
            }
        });
    });
}

/* ======================================================= */
/* 7. THEME CUSTOMIZER LOGIC                               */
/* ======================================================= */

/**
 * Loads and applies saved theme preferences from localStorage.
 */
function loadThemePreferences() {
    const savedTheme = loadPreference('vinoKPortfolioTheme', {
        primaryColor: '#754ef9',
        isLightMode: false,
        fontSize: 'base'
    });
    // Update appState with loaded preferences
    appState.theme = { ...appState.theme, ...savedTheme };

    applyPrimaryColor(appState.theme.primaryColor);
    applyLightMode(appState.theme.isLightMode);
    applyFontSize(appState.theme.fontSize);

    updateThemeCustomizerUI(); // Reflect settings in UI
}

/**
 * Applies the primary accent color to CSS custom properties.
 * Also updates the RGB variable for rgba calculations in CSS.
 * @param {string} color - The hex color code (e.g., '#754ef9').
 */
function applyPrimaryColor(color) {
    setCSSVar('--primary-color', color);
    const rgb = COLOR_PALETTES_RGB[color];
    if (rgb) {
        setCSSVar('--primary-color-rgb', rgb);
    } else {
        console.warn(`[Theme] RGB value not defined for color: ${color}`);
        // Fallback or dynamic calculation if color not in palette
        // For simplicity, we assume colors are in COLOR_PALETTES_RGB
    }
    appState.theme.primaryColor = color;
    savePreference('vinoKPortfolioTheme', appState.theme);
}

/**
 * Toggles the light/dark mode class on the body element.
 * @param {boolean} isLight - True for light mode, false for dark mode.
 */
function applyLightMode(isLight) {
    toggleClass(document.body, 'light-mode', isLight);
    appState.theme.isLightMode = isLight;
    savePreference('vinoKPortfolioTheme', appState.theme);
}

/**
 * Applies the selected font size class to the body element.
 * @param {'small' | 'base' | 'large'} size - The font size option.
 */
function applyFontSize(size) {
    removeClass(document.body, 'font-small');
    removeClass(document.body, 'font-large');
    if (size !== 'base') {
        addClass(document.body, `font-${size}`);
    }
    appState.theme.fontSize = size;
    savePreference('vinoKPortfolioTheme', appState.theme);
}

/**
 * Updates the visual state of the theme customizer UI elements
 * (e.g., active color box, active font size button, dark mode toggle icon).
 */
function updateThemeCustomizerUI() {
    // Highlight active primary color
    if (DOMElements.colorOptions) {
        DOMElements.colorOptions.forEach(box => {
            toggleClass(box, 'active', box.dataset.color === appState.theme.primaryColor);
        });
    }

    // Highlight active font size
    if (DOMElements.fontSizeOptions) {
        DOMElements.fontSizeOptions.forEach(btn => {
            toggleClass(btn, 'active', btn.dataset.size === appState.theme.fontSize);
        });
    }

    // Update dark mode toggle icon visibility
    if (DOMElements.darkModeToggle) {
        const moonIcon = DOMElements.darkModeToggle.querySelector('.fa-moon');
        const sunIcon = DOMElements.darkModeToggle.querySelector('.fa-sun');
        if (moonIcon && sunIcon) {
            moonIcon.style.display = appState.theme.isLightMode ? 'none' : 'inline-block';
            sunIcon.style.display = appState.theme.isLightMode ? 'inline-block' : 'none';
        }
    }
}

/**
 * Initializes the theme customizer's event listeners and loads saved preferences.
 */
function initThemeCustomizer() {
    if (!DOMElements.themeCustomizerToggle || !DOMElements.themeCustomizer || !DOMElements.customizerCloseBtn) {
        console.warn('[Theme Customizer] Missing essential elements. Skipping initialization.');
        return;
    }

    // Toggle customizer visibility
    DOMElements.themeCustomizerToggle.addEventListener('click', () => {
        toggleClass(DOMElements.themeCustomizer, 'active');
        appState.modalOpen = DOMElements.themeCustomizer.classList.contains('active');
        toggleClass(document.body, 'no-scroll', appState.modalOpen); // Prevent body scroll
    });

    DOMElements.customizerCloseBtn.addEventListener('click', () => {
        removeClass(DOMElements.themeCustomizer, 'active');
        appState.modalOpen = false;
        removeClass(document.body, 'no-scroll');
    });

    // Dark Mode Toggle button
    if (DOMElements.darkModeToggle) {
        DOMElements.darkModeToggle.addEventListener('click', () => {
            applyLightMode(!appState.theme.isLightMode);
            updateThemeCustomizerUI();
            showMessageBox(`Switched to ${appState.theme.isLightMode ? 'Light' : 'Dark'} Mode!`, 'info');
        });
    }

    // Primary Color selection
    if (DOMElements.colorOptions) {
        DOMElements.colorOptions.forEach(box => {
            box.addEventListener('click', () => {
                applyPrimaryColor(box.dataset.color);
                updateThemeCustomizerUI();
                showMessageBox('Primary color updated!', 'success');
            });
        });
    }

    // Font Size selection
    if (DOMElements.fontSizeOptions) {
        DOMElements.fontSizeOptions.forEach(btn => {
            btn.addEventListener('click', () => {
                applyFontSize(btn.dataset.size);
                updateThemeCustomizerUI();
                showMessageBox(`Font size set to ${btn.dataset.size}!`, 'info');
            });
        });
    }

    // Reset Theme to Defaults
    if (DOMElements.resetThemeBtn) {
        DOMElements.resetThemeBtn.addEventListener('click', () => {
            applyPrimaryColor('#754ef9'); // Default primary
            applyLightMode(false);       // Default dark mode
            applyFontSize('base');       // Default font size
            updateThemeCustomizerUI();
            showMessageBox('Theme settings reset to default!', 'info');
        });
    }

    loadThemePreferences(); // Load saved settings on startup
}


/* ======================================================= */
/* 8. BUTTON RIPPLE EFFECT                                 */
/* ======================================================= */

/**
 * Adds a visual ripple effect to a button when clicked.
 * This effect is handled purely by CSS animations.
 * @param {Event} e - The click event object.
 */
function addRippleEffect(e) {
    const button = e.currentTarget;
    if (!button) return;

    // Create a new span element for the ripple
    const rippleSpan = document.createElement('span');
    rippleSpan.classList.add('ripple'); // Add the ripple class which has the ::after pseudo-element

    // Calculate dimensions and position for the ripple effect
    const diameter = Math.max(button.clientWidth, button.clientHeight);
    const radius = diameter / 2;
    const x = e.clientX - button.getBoundingClientRect().left - radius;
    const y = e.clientY - button.getBoundingClientRect().top - radius;

    rippleSpan.style.width = rippleSpan.style.height = `${diameter}px`;
    rippleSpan.style.left = `${x}px`;
    rippleSpan.style.top = `${y}px`;

    // Remove any previous ripple elements to ensure only one animation runs at a time
    const existingRipple = button.querySelector('.ripple');
    if (existingRipple) {
        existingRipple.remove();
    }

    // Append the new ripple element to the button
    button.appendChild(rippleSpan);

    // This immediately triggers the CSS animation.
    // The CSS defines `transition: transform 0.5s, opacity 1s;` on `ripple::after`
    // and `transform: scale(0, 0); opacity: 0.3; transition: 0s;` on `ripple:active::after`
    // The `active` pseudo-class applies on click, resetting the transform for the transition to play.
}


/* ======================================================= */
/* 9. TYPED.JS INTEGRATION                                 */
/* ======================================================= */

/**
 * Initializes the Typed.js library for animating text in the hero section.
 */
function initTypedText() {
    if (DOMElements.typedSubtitle && typeof Typed !== 'undefined') {
        new Typed('.multiple-text', {
            strings: [
                "Transforming Ideas into Smart Solutions",
                "Data Engineering Enthusiast",
                "Full-Stack Development Proponent",
                "AI & Cloud Practitioner",
                "Hackathon Winner",
                "Creative Problem Solver"
            ],
            typeSpeed: 60,      // Typing speed in milliseconds
            backSpeed: 40,      // Backspacing speed in milliseconds
            backDelay: 1800,    // Delay before starting to backspace
            startDelay: 1000,   // Delay before typing starts
            loop: true,         // Loop the animation indefinitely
            showCursor: true,   // Show the typing cursor
            cursorChar: '|',    // Character for the typing cursor
            // onComplete: (self) => console.log('Typed.js animation complete', self),
            // onStringTyped: (arrayPos, self) => console.log('Typed string:', self.strings[arrayPos]),
        });
        console.log('[Typed.js] Initialized.');
    } else {
        console.warn('[Typed.js] Typed.js library or target element not found. Skipping text animation.');
    }
}


/* ======================================================= */
/* 10. AOS (ANIMATE ON SCROLL) INTEGRATION                 */
/* ======================================================= */

/**
 * Initializes the AOS (Animate On Scroll) library for scroll-triggered animations.
 */
function initAOS() {
    if (typeof AOS !== 'undefined') {
        AOS.init({
            disable: function() {
                // Disable AOS on mobile for performance or simpler aesthetic
                return window.innerWidth < 768;
            },
            duration: 1000,     // animation duration in milliseconds
            easing: 'ease-out-back', // easing for AOS animations
            once: true,         // whether animation should happen only once - while scrolling down
            mirror: false,      // whether elements should animate out while scrolling past them
            offset: 120,        // offset (in px) from the original trigger point
            delay: 50,          // values from 0 to 3000, with step 50ms
            // onStart: (aosElement) => { /* console.log('AOS animation started for:', aosElement); */ },
            // onComplete: (aosElement) => { /* console.log('AOS animation completed for:', aosElement); */ },
        });
        console.log('[AOS] Initialized.');
    } else {
        console.warn('[AOS] AOS library not found. Skipping scroll animations.');
    }
}


/* ======================================================= */
/* 11. CHART.JS FOR SKILLS RADAR CHART                     */
/* ======================================================= */

/**
 * Initializes the Chart.js radar chart to visualize skills proficiency.
 */
function initSkillsChart() {
    if (!DOMElements.skillsChartCanvas || typeof Chart === 'undefined') {
        console.warn('[Chart.js] Chart.js library or canvas element not found. Skipping skills chart.');
        return;
    }

    const ctx = DOMElements.skillsChartCanvas.getContext('2d');

    const chartData = {
        labels: [
            'Python', 'Data Tools', 'Web Dev', 'Cloud',
            'Databases', 'DevOps', 'ML/AI', 'Soft Skills'
        ],
        datasets: [{
            label: 'Proficiency',
            data: [95, 88, 75, 80, 82, 70, 85, 90], // Example proficiency scores (0-100)
            backgroundColor: 'rgba(117, 78, 249, 0.5)', // Primary color with transparency
            borderColor: 'rgba(117, 78, 249, 1)',
            pointBackgroundColor: 'rgba(80, 227, 194, 1)', // Secondary accent color
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: 'rgba(80, 227, 194, 1)',
            borderWidth: 2,
            fill: true, // Fill the area under the radar chart
        }]
    };

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false, // Allows flexible sizing
        scales: {
            r: {
                angleLines: {
                    color: getCSSVar('--border-color'), // Lines radiating from center
                },
                grid: {
                    color: getCSSVar('--border-color'), // Circular grid lines
                },
                pointLabels: {
                    font: {
                        size: 14,
                        family: getCSSVar('--font-family-primary'),
                        weight: '600',
                    },
                    color: getCSSVar('--text-color'), // Label text color
                },
                ticks: {
                    display: false, // Hide numeric ticks (0, 20, 40 etc.)
                    max: 100,
                    min: 0,
                    stepSize: 20,
                },
                beginAtZero: true, // Ensure the chart starts from 0
            }
        },
        plugins: {
            legend: {
                display: false, // Hide dataset legend (e.g., 'Proficiency')
            },
            tooltip: {
                backgroundColor: getCSSVar('--background-light'),
                titleColor: getCSSVar('--primary-color'),
                bodyColor: getCSSVar('--text-color'),
                bodyFont: {
                    size: 14,
                    family: getCSSVar('--font-family-secondary'),
                },
                displayColors: false, // Don't show color box in tooltip
                callbacks: {
                    label: function(context) {
                        return `${context.label}: ${context.raw}%`;
                    }
                },
                borderColor: getCSSVar('--border-color'),
                borderWidth: 1,
                cornerRadius: getCSSVar('--border-radius-md'),
            }
        },
        animation: {
            duration: 1500, // Animation duration on load
            easing: 'easeOutQuart', // Easing function for animation
        }
    };

    new Chart(ctx, {
        type: 'radar',
        data: chartData,
        options: chartOptions,
    });
    console.log('[Chart.js] Skills chart initialized.');
}


/* ======================================================= */
/* 12. LIVE TIME DISPLAY                                   */
/* ======================================================= */

/**
 * Updates the live time display in the footer every second.
 */
function updateLiveTime() {
    if (!DOMElements.liveTimeSpan) {
        console.warn('[Live Time] Live time display element not found.');
        return;
    }

    const now = new Date();
    const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: true, // Use 12-hour format with AM/PM
        timeZoneName: 'short', // Show timezone (e.g., IST)
    };
    DOMElements.liveTimeSpan.textContent = now.toLocaleDateString('en-US', options);
}


/* ======================================================= */
/* 13. GSAP ANIMATIONS (ADVANCED)                          */
/* ======================================================= */

/**
 * Initializes various advanced animations using GSAP.
 * Requires GSAP and ScrollTrigger.
 */
function initGSAPAnimations() {
    if (typeof gsap === 'undefined' || typeof ScrollTrigger === 'undefined') {
        console.warn('[GSAP] GSAP or ScrollTrigger not loaded. Skipping GSAP animations.');
        return;
    }

    gsap.registerPlugin(ScrollTrigger); // Register ScrollTrigger if not already

    // --- Home Section Entrance Animation ---
    const homeTimeline = gsap.timeline({ defaults: { ease: APP_CONSTANTS.GSAP_EASE_OUT } });

    homeTimeline
        .from(DOMElements.homeImageBlob, {
            duration: 1.5,
            scale: 0.7,
            opacity: 0,
            rotation: 90,
            ease: APP_CONSTANTS.GSAP_BACK_OUT,
            delay: 0.5
        })
        .from(DOMElements.homeProfileImg, {
            duration: 1.2,
            scale: 0.5,
            opacity: 0,
            ease: APP_CONSTANTS.GSAP_BACK_OUT
        }, "-=1") // Start 1 second before end of previous animation
        .from(DOMElements.typedSubtitle, {
            duration: 0.8,
            y: 30,
            opacity: 0,
            delay: 0.2
        }, "-=0.5")
        .from(".home-content > *:not(.home-subtitle, .home-title, .home-image-blob, .home-image-background)", {
            duration: 0.7,
            y: 20,
            opacity: 0,
            stagger: APP_CONSTANTS.GSAP_STAGGER_DELAY,
            ease: "power1.out"
        }, "-=0.4"); // Stagger other content slightly later

    // --- Section Title Bounce-in Effect on Scroll ---
    gsap.utils.toArray('.section-title').forEach(title => {
        gsap.from(title, {
            scrollTrigger: {
                trigger: title,
                start: "top 85%", // When top of title hits 85% of viewport height
                toggleActions: "play none none none", // Play animation once when scrolling down
                // markers: true, // Uncomment for debugging scroll triggers
            },
            y: -50,
            opacity: 0,
            scale: 0.8,
            duration: 1.2,
            ease: APP_CONSTANTS.GSAP_BACK_OUT,
            delay: 0.2 // Small delay after trigger
        });
    });

    // --- Project Card Hover Animation (GSAP controlled) ---
    // Override CSS transitions for finer control with GSAP
    gsap.utils.toArray(".project-card").forEach(card => {
        // Set initial transform origin for 3D effect
        gsap.set(card, { transformOrigin: "center bottom" }); // Rotate from bottom

        const hoverAnimation = gsap.to(card, {
            y: -15,
            rotationX: -8, // Rotate slightly upwards
            scale: 1.03,
            boxShadow: "0 15px 30px rgba(0, 0, 0, 0.4)",
            borderColor: getCSSVar('--primary-color'),
            duration: 0.4,
            ease: APP_CONSTANTS.GSAP_EASE_OUT,
            paused: true,
            // Ensure 3D perspective is maintained
            z: 50 // Pull forward slightly in 3D space
        });

        const imageZoom = gsap.to(card.querySelector('.project-image'), {
            scale: 1.15,
            duration: 0.4,
            ease: APP_CONSTANTS.GSAP_EASE_OUT,
            paused: true
        });

        const overlaySlide = gsap.to(card.querySelector('.project-overlay'), {
            y: 0,
            duration: 0.4,
            ease: APP_CONSTANTS.GSAP_EASE_OUT,
            paused: true
        });

        card.addEventListener("mouseenter", () => {
            hoverAnimation.play();
            imageZoom.play();
            overlaySlide.play();
        });
        card.addEventListener("mouseleave", () => {
            hoverAnimation.reverse();
            imageZoom.reverse();
            overlaySlide.reverse();
        });
    });

    // --- Service Card Hover Animation ---
    gsap.utils.toArray(".service-card").forEach(card => {
        const icon = card.querySelector('.service-icon');
        const hoverAnim = gsap.to(card, {
            y: -8,
            boxShadow: "0 8px 16px rgba(0, 0, 0, 0.35)",
            borderColor: getCSSVar('--secondary-color'),
            duration: 0.3,
            ease: "power1.out",
            paused: true
        });
        const iconAnim = gsap.to(icon, {
            scale: 1.15,
            rotation: 5,
            color: getCSSVar('--primary-color'),
            duration: 0.3,
            ease: "power1.out",
            paused: true
        });

        card.addEventListener("mouseenter", () => { hoverAnim.play(); iconAnim.play(); });
        card.addEventListener("mouseleave", () => { hoverAnim.reverse(); iconAnim.reverse(); });
    });

    // --- Certification Card Hover Animation ---
    gsap.utils.toArray(".certification-card").forEach(card => {
        const icon = card.querySelector('.certification-icon');
        const hoverAnim = gsap.to(card, {
            y: -5,
            scale: 1.02,
            boxShadow: "0 6px 12px rgba(0, 0, 0, 0.3)",
            borderColor: getCSSVar('--primary-color'),
            duration: 0.3,
            ease: "power1.out",
            paused: true
        });
        const iconAnim = gsap.to(icon, {
            scale: 1.1,
            rotationY: 10,
            color: getCSSVar('--secondary-color'),
            duration: 0.3,
            ease: "power1.out",
            paused: true
        });

        card.addEventListener("mouseenter", () => { hoverAnim.play(); iconAnim.play(); });
        card.addEventListener("mouseleave", () => { hoverAnim.reverse(); iconAnim.reverse(); });
    });

    // --- Skill Item Hover Animation ---
    gsap.utils.toArray(".skill-item").forEach(item => {
        gsap.to(item, {
            scale: 1.08,
            backgroundColor: getCSSVar('--primary-color'),
            color: 'white',
            borderColor: getCSSVar('--primary-color'),
            duration: 0.2,
            ease: "power1.out",
            paused: true,
            overwrite: 'auto'
        });

        item.addEventListener("mouseenter", function() { this.gsap.play(); });
        item.addEventListener("mouseleave", function() { this.gsap.reverse(); });
    });

    // --- Resume Button Hover Glow ---
    gsap.utils.toArray(".resume-buttons .btn").forEach(button => {
        gsap.to(button, {
            boxShadow: "0 0 20px rgba(117, 78, 249, 0.6)",
            scale: 1.02,
            duration: 0.3,
            ease: "power2.out",
            paused: true,
            overwrite: 'auto'
        });
        button.addEventListener("mouseenter", function() { this.gsap.play(); });
        button.addEventListener("mouseleave", function() { this.gsap.reverse(); });
    });


    // --- Timeline Item Animations on Scroll ---
    gsap.utils.toArray(".timeline-item").forEach((item, i) => {
        const timelineContent = item.querySelector('.timeline-content');
        const timelineDot = item.querySelector('.timeline-dot');

        gsap.from(item, {
            scrollTrigger: {
                trigger: item,
                start: "top 80%",
                end: "bottom 20%",
                toggleActions: "play none none none", // Play once on enter
                // markers: true,
            },
            opacity: 0,
            x: i % 2 === 0 ? -100 : 100, // Slide from left for even, right for odd
            scale: 0.8,
            duration: 0.8,
            ease: APP_CONSTANTS.GSAP_EASE_OUT,
        });

        // Add a subtle dot animation
        gsap.from(timelineDot, {
            scrollTrigger: {
                trigger: item,
                start: "top 80%",
                toggleActions: "play none none none",
            },
            scale: 0,
            rotation: 360,
            duration: 0.6,
            ease: APP_CONSTANTS.GSAP_BACK_OUT,
            delay: 0.4 // After item starts animating
        });
    });

    console.log('[GSAP] Animations initialized.');
}


/* ======================================================= */
/* 14. PARTICLE.JS BACKGROUND                              */
/* ======================================================= */

/**
 * Initializes the Particle.js library for a dynamic background effect in the home section.
 * Requires the `#particles-js` div to be present in HTML.
 */
function initParticlesJS() {
    if (typeof particlesJS === 'undefined' || !DOMElements.particlesJsDiv) {
        console.warn('[Particles.js] particles.js library or target element (#particles-js) not found. Skipping particle background.');
        return;
    }

    // Configuration for particles.js (highly customizable)
    particlesJS('particles-js', {
        "particles": {
            "number": {
                "value": 60, // Number of particles
                "density": {
                    "enable": true,
                    "value_area": 800 // Area where particles are distributed
                }
            },
            "color": {
                "value": getCSSVar('--primary-color') // Particle color based on theme
            },
            "shape": {
                "type": "circle", // "circle", "edge", "triangle", "polygon", "star", "image"
                "stroke": {
                    "width": 0,
                    "color": "#000000"
                },
                "polygon": {
                    "nb_sides": 5
                }
            },
            "opacity": {
                "value": 0.5,
                "random": false,
                "anim": {
                    "enable": false,
                    "speed": 1,
                    "opacity_min": 0.1,
                    "sync": false
                }
            },
            "size": {
                "value": 3,
                "random": true, // Randomize particle size
                "anim": {
                    "enable": false,
                    "speed": 40,
                    "size_min": 0.1,
                    "sync": false
                }
            },
            "line_linked": {
                "enable": true,
                "distance": 150, // Max distance for lines between particles
                "color": getCSSVar('--secondary-color'), // Line color
                "opacity": 0.4,
                "width": 1
            },
            "move": {
                "enable": true,
                "speed": 3, // Particle movement speed
                "direction": "none",
                "random": false,
                "straight": false,
                "out_mode": "out", // Particles disappear on canvas edge
                "bounce": false,
                "attract": {
                    "enable": false,
                    "rotateX": 600,
                    "rotateY": 1200
                }
            }
        },
        "interactivity": {
            "detect_on": "canvas", // Detect interactions on the canvas itself
            "events": {
                "onhover": {
                    "enable": true,
                    "mode": "grab" // Particles follow mouse on hover
                },
                "onclick": {
                    "enable": true,
                    "mode": "push" // Click to add more particles
                },
                "resize": true // Particles resize with window
            },
            "modes": {
                "grab": {
                    "distance": 180, // Distance for grab mode
                    "line_linked": {
                        "opacity": 1 // Lines become fully opaque when grabbed
                    }
                },
                "bubble": {
                    "distance": 400,
                    "size": 40,
                    "duration": 2,
                    "opacity": 8,
                    "speed": 3
                },
                "repulse": {
                    "distance": 200,
                    "duration": 0.4
                },
                "push": {
                    "particles_nb": 4 // Number of particles to add on click
                },
                "remove": {
                    "particles_nb": 2 // Number of particles to remove on click
                }
            }
        },
        "retina_detect": true // Higher quality particles on retina displays
    });
    console.log('[Particles.js] Initialized.');
}


/* ======================================================= */
/* 15. MODALS (Project & Certification Details)            */
/* ======================================================= */

/**
 * Creates and initializes a generic modal structure.
 * @param {string} modalId - The ID for the modal container.
 * @returns {HTMLElement} The created modal element.
 */
function createModal(modalId) {
    let modal = getElement(`#${modalId}`);
    if (modal) return modal; // Return existing modal if it was already created

    modal = document.createElement('div');
    modal.id = modalId;
    modal.classList.add('app-modal'); // Generic modal class for styling

    modal.innerHTML = `
        <div class="modal-content-wrapper">
            <button class="modal-close-btn">&times;</button>
            <div class="modal-header">
                <h3 class="modal-title"></h3>
            </div>
            <div class="modal-body">
                <!-- Content will be dynamically inserted here -->
            </div>
            <div class="modal-footer">
                <!-- Links/buttons dynamically inserted -->
            </div>
        </div>
    `;
    DOMElements.mainContent.appendChild(modal); // Append to main content or body

    // Cache modal elements
    DOMElements[`${modalId}Title`] = modal.querySelector('.modal-title');
    DOMElements[`${modalId}Body`] = modal.querySelector('.modal-body');
    DOMElements[`${modalId}Footer`] = modal.querySelector('.modal-footer');
    DOMElements[`${modalId}CloseBtn`] = modal.querySelector('.modal-close-btn');

    // Add close listener
    DOMElements[`${modalId}CloseBtn`].addEventListener('click', () => closeAnyModal(modal));

    // Close modal if clicking outside content
    modal.addEventListener('click', (e) => {
        if (e.target === modal) { // Only if clicked on the overlay itself
            closeAnyModal(modal);
        }
    });

    // Basic modal styling (can be moved to CSS)
    const style = document.createElement('style');
    style.innerHTML = `
        .app-modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: var(--z-index-modal);
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if content is too long */
            background-color: rgba(0, 0, 0, 0.8); /* Dark overlay */
            backdrop-filter: blur(5px); /* Subtle blur behind modal */
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity var(--transition-normal);
        }
        .app-modal.active {
            display: flex;
            opacity: 1;
        }
        .modal-content-wrapper {
            background-color: var(--surface-color);
            margin: auto;
            padding: var(--spacing-2xl);
            border-radius: var(--border-radius-lg);
            width: 90%;
            max-width: 800px;
            box-shadow: var(--shadow-xl);
            position: relative;
            transform: translateY(20px);
            opacity: 0;
            transition: transform var(--transition-normal), opacity var(--transition-normal);
            border: 1px solid var(--primary-color);
        }
        .app-modal.active .modal-content-wrapper {
            transform: translateY(0);
            opacity: 1;
        }
        .modal-close-btn {
            position: absolute;
            top: var(--spacing-md);
            right: var(--spacing-md);
            background: none;
            border: none;
            font-size: var(--font-size-3xl);
            color: var(--text-color);
            cursor: pointer;
            transition: color var(--transition-fast), transform var(--transition-fast);
        }
        .modal-close-btn:hover {
            color: var(--secondary-color);
            transform: rotate(90deg) scale(1.1);
        }
        .modal-header {
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--border-color);
        }
        .modal-title {
            font-size: var(--font-size-3xl);
            color: var(--heading-color);
            margin: 0;
        }
        .modal-body {
            font-size: var(--font-size-base);
            line-height: 1.7;
            color: var(--text-color);
            margin-bottom: var(--spacing-xl);
            max-height: 60vh; /* Limit modal body height */
            overflow-y: auto; /* Scrollable if content overflows */
            padding-right: var(--spacing-sm); /* Space for scrollbar */
        }
        .modal-body::-webkit-scrollbar {
            width: 8px;
            border-radius: var(--border-radius-full);
        }
        .modal-body::-webkit-scrollbar-track {
            background: var(--background-color);
            border-radius: var(--border-radius-full);
        }
        .modal-body::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: var(--border-radius-full);
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-md);
            border-top: 1px solid var(--border-color);
            padding-top: var(--spacing-lg);
        }
        .modal-footer .btn {
            min-width: unset;
        }
        .modal-body img {
            max-width: 100%;
            height: auto;
            border-radius: var(--border-radius-md);
            margin-bottom: var(--spacing-md);
        }
        .modal-body p { margin-bottom: var(--spacing-md); }
        .modal-body ul { margin-left: var(--spacing-xl); margin-bottom: var(--spacing-md); list-style: disc; }
        .modal-body li { margin-bottom: var(--spacing-xs); }
        .modal-body .tech-badge { margin-right: var(--spacing-xs); margin-bottom: var(--spacing-xs); }

        @media (max-width: 767px) {
            .modal-content-wrapper {
                width: 95%;
                padding: var(--spacing-lg);
            }
            .modal-title { font-size: var(--font-size-2xl); }
            .modal-body { font-size: var(--font-size-sm); }
            .modal-footer { flex-direction: column; align-items: stretch; }
        }
    `;
    document.head.appendChild(style); // Append modal styles to head

    return modal;
}

/**
 * Closes the specified modal and manages body scroll.
 * @param {HTMLElement} modalElement - The modal DOM element to close.
 */
function closeAnyModal(modalElement) {
    if (!modalElement) return;
    removeClass(modalElement, 'active');
    appState.modalOpen = false;
    removeClass(document.body, 'no-scroll');
}

/**
 * Opens a modal with specified content.
 * @param {HTMLElement} modalElement - The modal DOM element to open.
 * @param {Object} content - Object containing title, bodyHtml, footerHtml.
 */
function openModal(modalElement, content) {
    if (!modalElement) return;

    const modalTitleElem = modalElement.querySelector('.modal-title');
    const modalBodyElem = modalElement.querySelector('.modal-body');
    const modalFooterElem = modalElement.querySelector('.modal-footer');

    if (modalTitleElem) modalTitleElem.textContent = content.title || '';
    if (modalBodyElem) modalBodyElem.innerHTML = content.bodyHtml || '';
    if (modalFooterElem) modalFooterElem.innerHTML = content.footerHtml || '';

    addClass(modalElement, 'active');
    appState.modalOpen = true;
    addClass(document.body, 'no-scroll'); // Prevent body scroll
}


// --- Project Details Modals ---
/**
 * Opens the project details modal with dynamic content based on project data.
 * @param {Object} projectData - Data object for the project.
 */
function openProjectModal(projectData) {
    const projectModal = DOMElements.projectModal || createModal('project-modal'); // Ensure modal exists
    if (!projectModal) {
        console.error('Project modal could not be created/found.');
        return;
    }

    const bodyHtml = `
        <img src="${projectData.image || 'https://placehold.co/600x400/333/666?text=Image+Unavailable'}" alt="${projectData.title}" style="max-height: 300px; object-fit: cover; width: 100%; margin-bottom: ${getCSSVar('--spacing-lg')};">
        <p><strong>Type:</strong> ${projectData.type || 'N/A'}</p>
        <p><strong>Description:</strong> ${projectData.description || 'No description available.'}</p>
        <p><strong>Stack:</strong>
            <div style="display: flex; flex-wrap: wrap; gap: ${getCSSVar('--spacing-xs')}; margin-top: ${getCSSVar('--spacing-sm')};">
                ${projectData.techStack.map(tech => `<span class="tech-badge">${tech}</span>`).join('')}
            </div>
        </p>
        <p><strong>Role:</strong> ${projectData.role || 'N/A'}</p>
        ${projectData.features ? `<p><strong>Key Features:</strong><ul>${projectData.features.map(f => `<li>${f}</li>`).join('')}</ul></p>` : ''}
    `;

    const footerHtml = `
        ${projectData.githubLink ? `<a href="${projectData.githubLink}" target="_blank" class="btn btn-primary ripple">View Code <i class="fab fa-github"></i></a>` : ''}
        ${projectData.demoLink ? `<a href="${projectData.demoLink}" target="_blank" class="btn btn-secondary ripple">Live Demo <i class="fas fa-external-link-alt"></i></a>` : ''}
        ${projectData.reportLink ? `<a href="${projectData.reportLink}" target="_blank" class="btn btn-secondary ripple">Report <i class="fas fa-file-alt"></i></a>` : ''}
    `;

    openModal(projectModal, {
        title: projectData.title,
        bodyHtml: bodyHtml,
        footerHtml: footerHtml
    });
}

// --- Certification Details Modals ---
/**
 * Opens the certification details modal with dynamic content.
 * @param {Object} certData - Data object for the certification.
 */
function openCertificationModal(certData) {
    const certModal = DOMElements.certificationModal || createModal('certification-modal'); // Ensure modal exists
    if (!certModal) {
        console.error('Certification modal could not be created/found.');
        return;
    }

    const bodyHtml = `
        <p><strong>Provider:</strong> ${certData.provider || 'N/A'}</p>
        <p><strong>Issued:</strong> ${certData.date || 'N/A'}</p>
        ${certData.description ? `<p><strong>Description:</strong> ${certData.description}</p>` : ''}
        ${certData.skillsCovered ? `<p><strong>Skills Covered:</strong> ${certData.skillsCovered.join(', ')}</p>` : ''}
    `;

    const footerHtml = `
        ${certData.credentialLink ? `<a href="${certData.credentialLink}" target="_blank" class="btn btn-primary ripple">View Credential <i class="fas fa-external-link-alt"></i></a>` : ''}
    `;

    openModal(certModal, {
        title: certData.title,
        bodyHtml: bodyHtml,
        footerHtml: footerHtml
    });
}


/* ======================================================= */
/* 16. CLIENT-SIDE FORM HANDLING (CONTACT FORM)            */
/* ======================================================= */

/**
 * Handles the contact form submission.
 * This form uses Formspree for backend processing (sends email).
 * @param {Event} e - The form submission event object.
 */
async function handleContactFormSubmit(e) {
    e.preventDefault(); // Prevent default browser form submission

    if (!DOMElements.contactForm || !DOMElements.contactSubmitBtn) {
        showMessageBox('Contact form elements not found.', 'error');
        return;
    }

    const form = DOMElements.contactForm;
    const submitButton = DOMElements.contactSubmitBtn;

    // Basic client-side validation using HTML5 constraints
    if (!form.checkValidity()) {
        showMessageBox('Please fill in all required fields correctly.', 'error');
        form.reportValidity(); // Show native browser validation messages
        return;
    }

    // Capture form data
    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());

    // Disable button and show loading state
    submitButton.disabled = true;
    submitButton.textContent = APP_CONSTANTS.FORM_LOADING_TEXT;
    addClass(submitButton, 'sending'); // Add a class for specific sending animation if needed

    try {
        // Formspree submission (ensure action attribute is set in HTML)
        const response = await fetch(form.action, {
            method: form.method,
            body: JSON.stringify(data),
            headers: {
                'Accept': 'application/json'
            }
        });

        if (response.ok) {
            showMessageBox(APP_CONSTANTS.FORM_SUCCESS_MESSAGE, 'success');
            form.reset(); // Clear form fields on success
            // Trigger confetti on successful form submission
            triggerConfetti();
        } else {
            const errorText = await response.text();
            console.error('Formspree submission error:', errorText);
            showMessageBox(APP_CONSTANTS.FORM_ERROR_MESSAGE, 'error');
        }
    } catch (error) {
        console.error('Network or unexpected error during form submission:', error);
        showMessageBox(APP_CONSTANTS.FORM_ERROR_MESSAGE, 'error');
    } finally {
        // Re-enable button and reset text
        submitButton.disabled = false;
        submitButton.textContent = APP_CONSTANTS.FORM_DEFAULT_TEXT;
        removeClass(submitButton, 'sending');
    }
}

/**
 * Triggers a confetti animation for celebratory moments.
 * Requires a confetti library or custom implementation.
 * For this example, we'll use a placeholder or assume a simple confetti function.
 * If using a library like `canvas-confetti`, ensure it's loaded in HTML.
 * Example CDN: <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
 */
function triggerConfetti() {
    if (typeof confetti === 'undefined') {
        console.warn('[Confetti] confetti.js library not found. Skipping confetti animation.');
        return;
    }

    // Confetti burst from the center of the screen
    confetti({
        particleCount: 150, // Number of particles
        spread: 90,        // How wide the particles spread
        origin: { y: 0.6 }, // Start from slightly above center bottom
        colors: [getCSSVar('--primary-color'), getCSSVar('--secondary-color'), '#ffffff'], // Theme colors + white
        disableForReducedMotion: true, // Respect user's motion preferences
    });

    // Optional: Second, smaller burst after a short delay
    setTimeout(() => {
        confetti({
            particleCount: 70,
            spread: 60,
            origin: { y: 0.8, x: 0.5 },
            colors: [getCSSVar('--primary-color'), getCSSVar('--secondary-color')],
            disableForReducedMotion: true,
        });
    }, 400);

    console.log('[Confetti] Confetti triggered!');
}

/* ======================================================= */
/* 17. COPY TO CLIPBOARD FUNCTIONALITY                     */
/* ======================================================= */

/**
 * Sets up click listeners for "copy to clipboard" buttons.
 */
function setupCopyToClipboardButtons() {
    if (DOMElements.copyEmailBtn) {
        DOMElements.copyEmailBtn.addEventListener('click', () => {
            const email = DOMElements.copyEmailBtn.dataset.clipboardText || 'vk5571859@gmail.com'; // Fallback
            copyTextToClipboard(email);
        });
    }

    if (DOMElements.copyPhoneBtn) {
        DOMElements.copyPhoneBtn.addEventListener('click', () => {
            const phone = DOMElements.copyPhoneBtn.dataset.clipboardText || '+916374451778'; // Fallback
            copyTextToClipboard(phone);
        });
    }
    console.log('[Copy to Clipboard] Buttons set up.');
}


/* ======================================================= */
/* 18. DYNAMIC CONTENT INJECTION & EVENT ATTACHMENTS       */
/* ======================================================= */

/**
 * Attaches click listeners to project cards to open a modal with details.
 * Retrieves data from the dataset attributes of the project card.
 */
function setupProjectCardModals() {
    DOMElements.projectCards.forEach(card => {
        card.addEventListener('click', (e) => {
            // Prevent opening modal if clicking links directly
            if (e.target.closest('.project-links')) {
                return;
            }

            const title = card.querySelector('.project-title').textContent;
            const type = card.querySelector('.project-category').textContent;
            const description = card.querySelector('.project-description').textContent;
            const image = card.querySelector('.project-image').getAttribute('src');
            const techStack = Array.from(card.querySelectorAll('.tech-badge')).map(badge => badge.textContent.trim());

            // Assuming links are in specific elements or dataset on the card for simplicity
            const githubLinkElem = card.querySelector('.project-links a[href*="github.com"]');
            const demoLinkElem = card.querySelector('.project-links a[href*="demo"]');
            const reportLinkElem = card.querySelector('.project-links a[href*="report"]'); // New link type

            const githubLink = githubLinkElem ? githubLinkElem.href : null;
            const demoLink = demoLinkElem ? demoLinkElem.href : null;
            const reportLink = reportLinkElem ? reportLinkElem.href : null;

            const projectData = {
                title,
                type,
                description,
                image,
                techStack,
                githubLink,
                demoLink,
                reportLink,
                // Add more data if available in HTML (e.g., role, features via data-attributes)
            };
            openProjectModal(projectData);
        });
    });
    console.log('[Projects] Project card modals set up.');
}

/**
 * Attaches click listeners to certification cards to open a modal with details.
 * Retrieves data from the dataset attributes of the certification card.
 */
function setupCertificationCardModals() {
    DOMElements.certificationCards.forEach(card => {
        card.addEventListener('click', (e) => {
            // Prevent opening modal if clicking direct credential link
            if (e.target.closest('.certification-link')) {
                return;
            }

            const title = card.querySelector('.certification-title').textContent;
            const provider = card.querySelector('.certification-provider').textContent;
            const date = card.querySelector('.certification-date').textContent;
            const credentialLinkElem = card.querySelector('.certification-link');
            const credentialLink = credentialLinkElem ? credentialLinkElem.href : null;

            // Example of adding more data (you'd put this in HTML data-attributes)
            const description = card.dataset.description || 'A valuable certification demonstrating proficiency in this area.';
            const skillsCovered = card.dataset.skills ? card.dataset.skills.split(',').map(s => s.trim()) : ['Core Concepts'];

            const certData = {
                title,
                provider,
                date,
                credentialLink,
                description,
                skillsCovered
            };
            openCertificationModal(certData);
        });
    });
    console.log('[Certifications] Certification card modals set up.');
}


/* ======================================================= */
/* INITIALIZATION & EVENT LISTENERS                        */
/* ======================================================= */

/**
 * Caches all necessary DOM elements into the DOMElements object.
 * This should be the very first function called after DOMContentLoaded.
 */
function cacheDOMElements() {
    // Page Structure
    DOMElements.header = getElement('.header');
    DOMElements.navbar = getElement('.navbar');
    DOMElements.navList = getElement('.nav-list');
    DOMElements.navLinks = getAllElements('.nav-link');
    DOMElements.menuIcon = getElement('.menu-icon');
    DOMElements.mainContent = getElement('main#main-content');
    DOMElements.footer = getElement('.footer');
    DOMElements.liveTimeSpan = getElement('#live-time');

    // UI Controls
    DOMElements.darkModeToggle = getElement('#dark-mode-toggle');
    DOMElements.themeCustomizerToggle = getElement('#theme-customizer-toggle');
    DOMElements.themeCustomizer = getElement('.theme-customizer');
    DOMElements.customizerCloseBtn = getElement('.customizer-close-btn');
    DOMElements.colorOptions = getAllElements('.color-box');
    DOMElements.fontSizeOptions = getAllElements('.font-size-btn');
    DOMElements.resetThemeBtn = getElement('#reset-theme-btn');
    DOMElements.skipLink = getElement('.skip-link');
    DOMElements.backToTopBtn = getElement('#back-to-top');
    DOMElements.scrollProgressBar = getElement('#scroll-progress-bar');
    DOMElements.messageBox = getElement('#message-box');
    DOMElements.messageBoxText = getElement('#message-box-text');
    DOMElements.messageBoxCloseBtn = getElement('#message-box-close-btn');

    // Home Section
    DOMElements.homeSection = getElement('#home');
    DOMElements.typedSubtitle = getElement('.multiple-text');
    DOMElements.homeButtons = getAllElements('.home-buttons .btn');
    DOMElements.homeProfileImg = getElement('.home-profile-img');
    DOMElements.homeImageBlob = getElement('.home-image-blob');
    DOMElements.particlesJsDiv = getElement('#particles-js');

    // Skills Section
    DOMElements.skillsChartCanvas = getElement('#skillsChart');
    DOMElements.skillItems = getAllElements('.skill-item');

    // Projects Section
    DOMElements.projectCards = getAllElements('.project-card');
    // Project modal elements will be created by createModal() on first use

    // Certifications Section
    DOMElements.certificationCards = getAllElements('.certification-card');
    // Certification modal elements will be created by createModal() on first use

    // Resume Section
    DOMElements.resumeDownloadBtn = getElement('.resume-buttons a[download]');
    DOMElements.resumeViewTabBtn = getElement('.resume-buttons a[href*="target=_blank"]:not([download])');

    // Contact Form
    DOMElements.contactForm = getElement('#contact-form');
    DOMElements.contactName = getElement('#contact-name');
    DOMElements.contactEmail = getElement('#contact-email');
    DOMElements.contactSubject = getElement('#contact-subject'); // New field
    DOMElements.contactMessage = getElement('#contact-message');
    DOMElements.contactSubmitBtn = getElement('#contact-submit-btn');

    // Copy to clipboard buttons (assumed to have data-clipboard-text attribute)
    DOMElements.copyEmailBtn = getElement('.contact-info-item i.fa-envelope').nextElementSibling.querySelector('p a');
    DOMElements.copyPhoneBtn = getElement('.contact-info-item i.fa-phone-alt').nextElementSibling.querySelector('p a');
    if (DOMElements.copyEmailBtn) {
        DOMElements.copyEmailBtn.classList.add('copy-action'); // Add a class for styling/events
        DOMElements.copyEmailBtn.dataset.clipboardText = 'vk5571859@gmail.com'; // Ensure data attribute exists
    }
    if (DOMElements.copyPhoneBtn) {
        DOMElements.copyPhoneBtn.classList.add('copy-action');
        DOMElements.copyPhoneBtn.dataset.clipboardText = '+916374451778'; // Ensure data attribute exists
    }

    // Custom Cursor elements (must exist in HTML)
    DOMElements.cursorDot = getElement('.cursor-dot');
    DOMElements.cursorOutline = getElement('.cursor-outline');

    console.log('[DOM Cache] All elements cached.');
}

/**
 * Adds all global event listeners for interactive elements and window events.
 */
function addAllEventListeners() {
    // Window events (scroll, resize)
    window.addEventListener('scroll', debounce(() => {
        handleStickyHeader();
        updateScrollProgressBar();
        toggleBackToTopButton();
        highlightActiveNavLink();
        // Additional scroll-based effects can be triggered here
    }, APP_CONSTANTS.DEBOUNCE_DELAY)); // Debounce scroll event

    window.addEventListener('resize', debounce(() => {
        // Recalculate ScrollTriggers on resize if needed
        if (typeof ScrollTrigger !== 'undefined') {
            ScrollTrigger.refresh();
        }
        // Re-initialize chart for responsiveness if needed
        initSkillsChart();
        highlightActiveNavLink(); // Re-highlight after resize if needed
    }, APP_CONSTANTS.DEBOUNCE_DELAY)); // Debounce resize event

    // Initial calls on page load (after preloader is hidden or immediately if no preloader)
    window.addEventListener('load', () => {
        handleStickyHeader();
        updateScrollProgressBar();
        toggleBackToTopButton();
        updateLiveTime(); // Initial call
        setInterval(updateLiveTime, 1000); // Update every second
        highlightActiveNavLink(); // Ensure active nav is set on load
        // Initial setup for GSAP ScrollTriggers once all content is likely loaded
        if (typeof ScrollTrigger !== 'undefined' && DOMElements.mainContent) {
             ScrollTrigger.refresh(); // Ensure triggers are positioned correctly after all content renders
        }
    });

    // Navigation and Menu
    if (DOMElements.menuIcon) {
        DOMElements.menuIcon.addEventListener('click', toggleMobileMenu);
    }
    setupSmoothScrolling();

    // Back to Top button
    if (DOMElements.backToTopBtn) {
        DOMElements.backToTopBtn.addEventListener('click', scrollToTop);
    }

    // Theme Customizer
    initThemeCustomizer();

    // Ripple effect on all buttons with class 'btn'
    getAllElements('.btn').forEach(button => {
        button.addEventListener('click', addRippleEffect);
    });

    // Contact Form submission
    if (DOMElements.contactForm) {
        DOMElements.contactForm.addEventListener('submit', handleContactFormSubmit);
    }

    // Close Message Box
    if (DOMElements.messageBoxCloseBtn) {
        DOMElements.messageBoxCloseBtn.addEventListener('click', closeMessageBox);
    }

    // Set up project and certification card click handlers for modals
    if (DOMElements.projectCards.length > 0) {
        setupProjectCardModals();
    }
    if (DOMElements.certificationCards.length > 0) {
        setupCertificationCardModals();
    }

    // Set up copy to clipboard buttons
    setupCopyToClipboardButtons();

    console.log('[Event Listeners] All event listeners attached.');
}


/**
 * Main initialization function, called when the DOM is fully loaded.
 * Orchestrates the loading and initialization of all features.
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log('[App] DOM Content Loaded. Starting initialization...');
    cacheDOMElements(); // 1. Cache all DOM elements first

    // 2. Initialize preloader (shows immediately)
    initPreloader();

    // 3. Initialize external libraries and complex features that don't depend on window.load
    // These should be robust enough to handle elements not fully loaded, or only run after load.
    initCustomCursor(); // Requires GSAP (loaded in HTML head)
    initTypedText();    // Requires Typed.js (loaded in HTML head)
    initAOS();          // Requires AOS (loaded in HTML head)
    initSkillsChart();  // Requires Chart.js (loaded in HTML head)
    initParticlesJS();  // Requires particles.js (loaded in HTML head)

    // 4. Initialize GSAP animations after the preloader might have started/finished
    // and after relevant elements are fully rendered in the DOM.
    // This is often best after window.load or within ScrollTrigger callbacks.
    // For now, calling it here, but complex ScrollTriggers will self-adjust.
    initGSAPAnimations();

    // 5. Add all general event listeners
    addAllEventListeners();

    console.log('[App] Initialization complete.');
});

/* ======================================================= */
/* END OF SCRIPT                                           */
/* ======================================================= */
